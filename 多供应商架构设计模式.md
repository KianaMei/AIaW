# Cherry Studio 多供应商架构设计模式

## 概述

Cherry Studio 项目实现了一套完整的多AI供应商管理架构，支持60+个AI服务提供商，并优雅地解决了同名模型的冲突问题。本文档总结了该项目的核心设计模式和最佳实践。

## 1. 多供应商架构设计

### 1.1 分层架构

项目采用分层架构处理多供应商问题：

```
配置层 (Config Layer)
├── src/renderer/src/config/providers.ts - 供应商配置定义
└── src/renderer/src/config/models.ts - 模型配置定义

服务层 (Service Layer)  
├── src/renderer/src/services/ProviderService.ts - 供应商服务
└── src/renderer/src/services/ModelService.ts - 模型服务

客户端层 (Client Layer)
└── src/renderer/src/aiCore/legacy/clients/ApiClientFactory.ts - API客户端工厂
```

### 1.2 供应商配置模式

```typescript
// 统一供应商配置结构
export const SYSTEM_PROVIDERS_CONFIG: Record<SystemProviderId, SystemProvider> = {
  openai: {
    id: 'openai',
    name: 'OpenAI',
    type: 'openai-response',
    apiKey: '',
    apiHost: 'https://api.openai.com',
    models: SYSTEM_MODELS.openai,
    isSystem: true,
    enabled: false
  },
  anthropic: {
    id: 'anthropic',
    name: 'Anthropic',
    type: 'anthropic',
    apiKey: '',
    apiHost: 'https://api.anthropic.com',
    models: SYSTEM_MODELS.anthropic,
    isSystem: true,
    enabled: false
  }
  // ... 60+ 个供应商配置
}
```

### 1.3 工厂模式创建客户端

```typescript
export class ApiClientFactory {
  static create(provider: Provider): BaseApiClient {
    // 优先检查特殊供应商ID
    if (provider.id === 'cherryin') {
      return new CherryinAPIClient(provider)
    }
    
    if (provider.id === 'aihubmix') {
      return new AihubmixAPIClient(provider)
    }
    
    // 按供应商类型创建标准客户端
    switch (provider.type) {
      case 'openai':
        return new OpenAIAPIClient(provider)
      case 'anthropic':
        return new AnthropicAPIClient(provider)
      case 'gemini':
        return new GeminiAPIClient(provider)
      default:
        return new OpenAIAPIClient(provider) // 默认OpenAI兼容
    }
  }
}
```

## 2. 同名模型处理策略

### 2.1 模型唯一标识系统

```typescript
// 模型类型定义
export type Model = {
  id: string          // 模型ID（可能在不同供应商中重复）
  provider: string    // 供应商ID（确保唯一性）
  name: string        // 显示名称
  group: string       // 模型分组
  // ... 其他属性
}

// 生成模型唯一标识
export const getModelUniqId = (m?: Model) => {
  return m?.id ? JSON.stringify(pick(m, ['id', 'provider'])) : ''
}
```

### 2.2 复合键唯一性保证

**核心原理**: 使用 `{model.id, model.provider}` 组合作为模型的唯一标识符

```typescript
// 示例：两个供应商都有名为 "gpt-4" 的模型
const openaiGPT4 = {
  id: 'gpt-4',
  provider: 'openai',
  name: 'GPT-4'
}

const customGPT4 = {
  id: 'gpt-4', 
  provider: 'my-custom-provider',
  name: 'GPT-4'
}

// 生成的唯一标识分别为:
// '{"id":"gpt-4","provider":"openai"}'
// '{"id":"gpt-4","provider":"my-custom-provider"}'
```

### 2.3 API服务器中的命名空间模式

```typescript
// API格式：provider:model_id
export async function validateModelId(model: string) {
  // 验证格式：必须包含 ':' 分隔符
  if (!model.includes(':')) {
    return {
      valid: false,
      error: {
        message: "Expected format: 'provider:model_id' (e.g., 'openai:gpt-4')"
      }
    }
  }
  
  const [providerId, modelId] = model.split(':')
  
  // 验证供应商存在且已启用
  const provider = await getProviderByModel(model)
  if (!provider) {
    return {
      valid: false,
      error: {
        message: `Provider '${providerId}' not found or not enabled`
      }
    }
  }
  
  // 验证模型在指定供应商中存在
  const modelExists = provider.models?.some((m) => m.id === modelId)
  if (!modelExists) {
    return {
      valid: false,
      error: {
        message: `Model '${modelId}' not available in provider '${providerId}'`
      }
    }
  }
}
```

### 2.4 用户界面显示策略

```typescript
// 显示名称格式：模型名称 | 供应商名称
export function getModelName(model?: Model) {
  const provider = store.getState().llm.providers.find((p) => p.id === model?.provider)
  const modelName = model?.name || model?.id || ''
  
  if (provider) {
    const providerName = getProviderName(model)
    return `${modelName} | ${providerName}`  // 例如: "GPT-4 | OpenAI"
  }
  
  return modelName
}
```

## 3. 特殊处理机制

### 3.1 模型逻辑归属映射

处理某些模型虽然在一个供应商下，但实际来源于其他供应商的情况：

```typescript
export function getProviderByModel(model?: Model) {
  const provider = store.getState().llm.providers.find((p) => p.id === model?.provider)

  // 特殊映射：某些模型的逻辑归属与实际供应商不同
  if (provider?.id === 'cherryin') {
    const map = {
      'glm-4.5-flash': 'zhipu',     // 实际来自智谱AI
      'Qwen/Qwen3-8B': 'silicon'    // 实际来自SiliconFlow
    }
    
    const actualProviderId = map[model?.id as keyof typeof map]
    if (actualProviderId) {
      return getProviderById(actualProviderId)
    }
  }
  
  return provider
}
```

### 3.2 供应商能力差异处理

```typescript
// 根据供应商特性进行能力判断
export const isSupportArrayContentProvider = (provider: Provider) => {
  const NOT_SUPPORT_PROVIDERS = ['deepseek', 'baichuan', 'minimax', 'xirang', 'poe']
  return !NOT_SUPPORT_PROVIDERS.includes(provider.id)
}

export const isSupportDeveloperRoleProvider = (provider: Provider) => {
  const NOT_SUPPORT_PROVIDERS = ['poe', 'qiniu']
  return !NOT_SUPPORT_PROVIDERS.includes(provider.id)
}
```

## 4. 设计原则和最佳实践

### 4.1 核心设计原则

1. **命名空间隔离**: 通过供应商ID作为命名空间，避免模型名称冲突
2. **复合键唯一性**: 使用多字段组合确保实体唯一标识
3. **分层解耦**: 配置、服务、客户端分层，便于扩展和维护
4. **工厂模式**: 统一客户端创建逻辑，支持特殊供应商定制
5. **灵活映射**: 支持逻辑归属与实际供应商的映射关系

### 4.2 扩展性保证

```typescript
// 新增供应商只需三步：
// 1. 在配置中添加供应商定义
const newProvider: SystemProvider = {
  id: 'new-provider',
  name: 'New Provider',
  type: 'openai', // 或自定义类型
  // ...配置
}

// 2. 如需特殊处理，在工厂中添加逻辑
if (provider.id === 'new-provider') {
  return new CustomAPIClient(provider)
}

// 3. 如有特殊能力，添加能力判断函数
export const isSupportSpecialFeature = (provider: Provider) => {
  return provider.id === 'new-provider'
}
```

### 4.3 错误处理和用户体验

```typescript
// 友好的错误提示
if (!modelExists) {
  const availableModels = provider.models?.map(m => m.id).join(', ') || 'none'
  return {
    valid: false,
    error: {
      message: `Model '${modelId}' not available in provider '${providerId}'. Available models: ${availableModels}`
    }
  }
}
```

## 5. 总结

Cherry Studio 的多供应商架构设计具有以下优势：

1. **可扩展性强**: 新增供应商只需要配置和少量代码修改
2. **冲突避免**: 通过命名空间和复合键彻底解决同名模型问题
3. **用户友好**: 清晰的显示格式帮助用户区分不同供应商的模型
4. **类型安全**: TypeScript 类型系统确保编译时检查
5. **灵活适配**: 支持特殊供应商的定制化处理

这套设计模式为构建多供应商AI应用提供了完整的解决方案，值得在类似项目中借鉴和应用。